# -*- coding: utf-8 -*-
"""Worksheet0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ae6uu_H4BQIp_lVSOVpF63q60yobIepe
"""

Task1,2,3

timeData=[1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6 ]
low= []
moderate= []
high= []
for hrs in timeData:
    if hrs<3:
      low.append(hrs)
    elif 3<=hrs<=5:
      moderate.append(hrs)
    else:
      high.append(hrs)
print("Low study time :", low)
print("Moderate study time :", moderate)
print("High study time :", high)
low_count=len(low)
moderate_count=len(moderate)
high_count=len(high)
print(low_count,"days had low study time.")
print(moderate_count,"days had moderate study time.")
print(high_count,"days had high study time.")
study_minutes=[]
for hrs in timeData:
    min=hrs*60
    study_minutes.append(min)
print (study_minutes)

"""Task 4,5"""

time_data=[[2,3,5],[2,5,6],[2,3,4],[3,5,6]]
study_hours=[]
entertainment_hours=[]
sleep_hours=[]
for hrs in time_data:
    study_hours.append(hrs[0])
    entertainment_hours.append(hrs[1])
    sleep_hours.append(hrs[2])
print(study_hours)
print(entertainment_hours)
print(sleep_hours)
avg_study = sum(study_hours) / len(study_hours)
avg_entertainment = sum(entertainment_hours) / len(entertainment_hours)
avg_sleep = sum(sleep_hours) / len(sleep_hours)
print("Average study hours:", avg_study)
print("Average sleep hours:", avg_sleep)

import matplotlib.pyplot as plt
plt.scatter(study_hours, sleep_hours)
plt.xlabel("Study Hours")
plt.ylabel("Sleep Hours")
plt.title("Study vs Sleep Pattern")

def sum_nested_list(nested_list):
    """
    Calculate the sum of all numbers in a nested list.
    This function takes a list that may contain integers and other nested lists.
    It recursively traverses the list and sums all the integers, no matter how deeply
    nested they are.

    Args:
        nested_list (list): A list that may contain integers or other lists of integers.

    Returns:
        int: The total sum of all integers in the nested list, including those in sublists.

    Example:
        >>> sum_nested_list([1, [2, [3, 4], 5], 6, [7, 8]])
        36
        >>> sum_nested_list([1, [2, 3], [4, [5]]])
        15
    """
    total = 0
    for element in nested_list:
        if isinstance(element, list):  # Check if the element is a list
            total += sum_nested_list(element)  # Recursively sum the nested list
        else:
            total += element  # Add the number directly
    return total



nested_list = [1, [2, [3, 4], 5], 6, [7, 8]]
result = sum_nested_list(nested_list)
print("Total Sum:", result)

def generate_permutations(s):
    """
    Generate all unique permutations of a string using recursion and backtracking.

    Args:
        s (str): Input string.

    Returns:
        list: A list of unique permutation strings.
    """
    results = []
    used = [False] * len(s)
    s = sorted(s)  # Sorting helps avoid duplicates

    def backtrack(current):
        if len(current) == len(s):
            results.append("".join(current))
            return

        for i in range(len(s)):
            # Skip used characters
            if used[i]:
                continue
            # Avoid duplicate permutations
            if i > 0 and s[i] == s[i - 1] and not used[i - 1]:
                continue

            used[i] = True
            current.append(s[i])

            backtrack(current)

            # Backtrack
            used[i] = False
            current.pop()

    backtrack([])
    return results
print(generate_permutations("abc"))
# ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']

print(generate_permutations("aab"))
# ['aab', 'aba', 'baa']

def calculate_directory_size(directory):
    """
    Recursively calculate the total size of a directory structure.

    Args:
        directory (dict): Keys are filenames (values = int size) or directory names (values = dict).

    Returns:
        int: Total size in KB.
    """
    total_size = 0

    for key, value in directory.items():
        # If value is a dictionary â†’ it's a subdirectory
        if isinstance(value, dict):
            total_size += calculate_directory_size(value)
        else:
            total_size += value  # It's a file size

    return total_size
directory_structure = {
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}

print(calculate_directory_size(directory_structure))

def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

print(min_coins([1, 2, 5], 11))

def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)

    # DP table (m+1) x (n+1) filled with 0
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Build the table
    for i in range(m):
        for j in range(n):
            if s1[i] == s2[j]:
                dp[i+1][j+1] = dp[i][j] + 1
            else:
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])

    return dp[m][n]
print(longest_common_subsequence("abcde", "ace"))  # Output: 3

def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [0] * (capacity + 1)

    for i in range(n):
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])

    return dp[capacity]
weights = [1, 3, 4, 5]
values  = [1, 4, 5, 7]
capacity = 7

print(knapsack(weights, values, capacity))
# Expected output: 9